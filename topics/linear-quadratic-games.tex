\section{Dynamic games}

\subsection{Escape game}

Zeichnung Baum

% Template for a TikZ tree diagram.
% - Root at the top.
% - First level: 3 children (nodes).
% - Second level: Each of the 3 first-level nodes has 3 children by default.
% - To modify: Some nodes have only 2 children (comment out one
% 'child' line per parent).
% - Easily extend: Add more 'child { ... }' blocks for deeper levels
% or adjust labels.
% - Styling: Customize node shapes, colors, edge styles below.
% - Levels: This example has 2 levels below root (total depth 3). Add
% nesting for more.
% - Positioning: Uses 'trees' library for automatic layout; adjust
% 'level distance' and 'sibling distance' for spacing.

% TODO: tik tree to separate file, modify
\begin{center}
  \begin{tikzpicture}[
      % Global styling for the tree
      tree/.style={ % Style for edges
        -Latex, % Arrow style (from arrows.meta)
        thick,
        draw=gray,
      },
      level/.style={ % Spacing between levels
        level distance=1.5cm, % Vertical distance between levels
        % (adjust as needed)
        sibling distance=2cm, % Horizontal distance between siblings
        % (adjust for wider/narrower tree)
      },
      root node/.style={ % Style for root node
        draw=blue, % Border color
        fill=blue!20, % Fill color
        circle, % Shape (circle; change to rectangle, etc.)
        minimum size=1cm, % Size
        font=\bfseries, % Font
      },
      level-1/.style={ % Style for first-level nodes
        draw=green,
        fill=green!20,
        rectangle,
        minimum width=1cm,
        minimum height=0.8cm,
        font=\small\bfseries,
      },
      level-2/.style={ % Style for leaf/second-level nodes
        draw=red,
        fill=red!20,
        ellipse, % Shape for leaves
        minimum width=1cm,
        minimum height=0.6cm,
        % sibling distance=1cm,
        font=\small,
      },
      every node/.style={ % Default for all nodes
        align=center, % Center text
      },
    ]

    % The tree structure starts here
    \node[root node] (root) {Root}
    % \\(Level 0)}
    % First level: 3 children (adjust sibling distance above if needed)
    child { node[level-1] (n1) {up}
      % Second level under Node 1.1: 3 children (leaves)
      child { node[level-2] {middle} }
      child { node[level-2] {down} }
    }
    child { node[level-1] (n2) {middle}
      % Second level under Node 1.2: Example with ONLY 2 children
      % (comment out one 'child' to reduce)
      child { node[level-2] {up} }
      child { node[level-2] {middle} }
      child { node[level-2] {down} }
      % to make it 2 children
    }
    child { node[level-1] (n3) {down}
      % Second level under Node 1.3: 3 children (full)
      child { node[level-2] {up} }
      child { node[level-2] {middle} }
    };

    % Optional: Add backgrounds or decorations (using backgrounds
    % library from your cls)
    % \begin{scope}[on background layer]
    %     \fill[blue!5] (root) ++(0,-0.5) rectangle ($(n3 |- root) +
    % (1,0.5)$); % Faint background box
    % \end{scope}

  \end{tikzpicture}
\end{center}

Multi-stage game with

- finite actions

- large number of stages (20)

Order of: $1 + 9 + 81 + . . . + 320$ linear programs

\subsubsection{Taming the complexity of dynamic games}

How can you solve this game for 20 stages?

Key idea: In every “position”, the probability of escaping (and the
optimal strategy) do not depend on the past decisions.

We can perform backward induction on the “positions” (states!) rather
than on the game tree.

3 × 20 linear programs instead of 5 × 109

With more actions available at each stage, the speed up is even larger!

We will adapt this idea to dynamic games with infinite action spaces.

\subsubsection{From tree model to loop model}

A1
state that evolves

A2
outcome

\subsubsection{Loop model}

\subsection{Non-zero sum dynamic games}

A three-truck platoon

Loop models are equivalent to tree models.
Therefore all results and definitions
(NE, pure strategies, mixed strategies)
extend here, and have a \textit{control} interpretation.

\begin{sstTitleBox}
  {Subgame-perfect Nash Equilibrium}
  \begin{sstOnlyFrame}
    A strategy is a \textbf{subgame perfect} equilibrium
    if it represents a NE of every subgame of the original game.
  \end{sstOnlyFrame}
\end{sstTitleBox}

Subgame-perfect NE strategies
(that is, feedback laws)
are what in control we define as \textbf{optimal feedback laws}.

\subsection{Backward induction}

Example pyramide

\subsubsection{One-player case}

In the case of a one-player game, this reduces to Dynamic Programming.

- Bellman

\subsubsection{Two players: Linear-quadratic case}

\begin{sstTitleBox}{
    Dynamic game
  }
  \begin{sstOnlyFrame}
    There exists a \textbf{state} that evolves at each stage
    $$x$$
    The outcome of the game can be expressed as
    $$\sum$$
  \end{sstOnlyFrame}
\end{sstTitleBox}

\subsubsection{Two player LQR}

EXAMPLES

$$
x_{k+1} = A x_k + B_1 u_k + B_2 v_k
$$

Non-zero sum game setup

$$
J_1
$$

$$
J_2
$$

DERIVATION

$$
\hat{u}_k(v_k) =
$$
$$
\hat{v}_k(u_k) =
$$

NE feedback

$H_1,H_2$ from stacking expressions

Finally,
$J_1^\star = ... = x_k^T P_{1,k} x_k$

